{
  "meta": {
    "subject_id": "auto:sha256",
    "subject_name": "Paradigmi di Programmazione",
    "version": 1
  },
  "config": {
    "scales_questions": [
      10,
      20,
      50,
      "all"
    ],
    "scales_category": [
      5,
      10,
      20,
      "all"
    ],
    "scales_errors": [
      5,
      10,
      20,
      "all"
    ],
    "feedback": "immediate"
  },
  "taxonomy": [
    {
      "id": "paradigmi",
      "name": "Paradigmi di Programmazione",
      "sub": [
        {
          "id": "actor_model",
          "name": "Modello ad Attori"
        },
        {
          "id": "jvm_bytecode",
          "name": "JVM e Bytecode"
        },
        {
          "id": "type_system",
          "name": "Sistema dei Tipi"
        },
        {
          "id": "fallacie_generali",
          "name": "Fallacie Generali"
        }
      ]
    },
    {
      "id": "oop",
      "name": "Programmazione Object-Oriented",
      "sub": [
        {
          "id": "visibilita_classi",
          "name": "Visibilità e Classi"
        },
        {
          "id": "ereditarieta_interfacce",
          "name": "Ereditarietà e Interfacce"
        },
        {
          "id": "parole_chiave",
          "name": "Parole Chiave Java"
        },
        {
          "id": "controllo_flusso",
          "name": "Controllo di Flusso"
        },
        {
          "id": "generics_wildcards",
          "name": "Generics e Wildcards"
        }
      ]
    },
    {
      "id": "concurrency",
      "name": "Programmazione Concorrente",
      "sub": [
        {
          "id": "deadlock",
          "name": "Deadlock e Starvation"
        },
        {
          "id": "thread_stati",
          "name": "Stati dei Thread"
        },
        {
          "id": "sincronizzazione",
          "name": "Sincronizzazione"
        },
        {
          "id": "attori",
          "name": "Modello ad Attori"
        },
        {
          "id": "fondamenti",
          "name": "Fondamenti"
        },
        {
          "id": "future_promise",
          "name": "Future/Promise"
        }
      ]
    },
    {
      "id": "reactive",
      "name": "Programmazione Reattiva",
      "sub": [
        {
          "id": "reactive_streams",
          "name": "Reactive Streams"
        },
        {
          "id": "observable",
          "name": "Observable Pattern"
        },
        {
          "id": "subject",
          "name": "Subject Pattern"
        },
        {
          "id": "java_streams",
          "name": "Java Streams (java.util.stream)"
        }
      ]
    },
    {
      "id": "network",
      "name": "Programmazione di Rete",
      "sub": [
        {
          "id": "channels",
          "name": "Channels e NIO"
        },
        {
          "id": "protocolli",
          "name": "Protocolli di Comunicazione"
        },
        {
          "id": "serializzazione",
          "name": "Serializzazione"
        }
      ]
    },
    {
      "id": "distributed",
      "name": "Sistemi Distribuiti",
      "sub": [
        {
          "id": "fallacies",
          "name": "Fallacie dei Sistemi Distribuiti"
        },
        {
          "id": "consenso",
          "name": "Consenso e CAP"
        },
        {
          "id": "distribuzione_stato",
          "name": "Distribuzione dello Stato"
        },
        {
          "id": "crdt",
          "name": "CRDT"
        },
        {
          "id": "actor_distribuito",
          "name": "Attori Distribuiti"
        },
        {
          "id": "framework",
          "name": "Framework/Middleware"
        }
      ]
    }
  ],
  "questions": [
    {
      "id": "1",
      "category": "concurrency",
      "subcategory": "deadlock",
      "kind": "multiple",
      "prompt": "Selezionare quali delle seguenti sono condizioni di Coffman necessarie per l'instaurarsi di un deadlock.",
      "options": [
        {
          "id": 0,
          "text": "Temporizzazione dell'accesso",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Ordinamento dell'esecuzione",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Mutua Esclusione",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Attesa circolare",
          "isCorrect": true
        },
        {
          "id": 4,
          "text": "Possesso e attesa",
          "isCorrect": true
        },
        {
          "id": 5,
          "text": "Risorse non riassegnabili",
          "isCorrect": true
        },
        {
          "id": 6,
          "text": "Salvataggio del contesto",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "2",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "Usando i Reactive Stream, la gestione più granulare della composizione della pipeline di elaborazione dello stream permette di:",
      "options": [
        {
          "id": 0,
          "text": "Scegliere algoritmi di suddivisione del lavoro più efficienti di quelli della libreria standard",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Isolare la parte di pipeline che si desidera sia resa parallela; gli Stream della libreria standard sono completamente paralleli o completamente seriali",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Distribuire i singoli componenti dell'elaborazione su più nodi, indicando su quali nodi aumentare il parallelismo",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Ridurre la latenza dell'elaborazione dei vari componenti decidendo quante risorse dedicare a ciascuno di essi",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "3",
      "category": "concurrency",
      "subcategory": "thread_stati",
      "kind": "multiple",
      "prompt": "Un Thread esce dallo stato blocked quando:",
      "options": [
        {
          "id": 0,
          "text": "Ottiene il lock che stava aspettando o viene interrotto",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Viene interrotto (e solo in questo caso)",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Trascorre esattamente il tempo impostato (e solo in questo caso)",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Ottiene la risorsa di sistema che aveva richiesto",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "4",
      "category": "distributed",
      "subcategory": "distribuzione_stato",
      "kind": "multiple",
      "prompt": "Quali vantaggi si cercano nel distribuire lo stato di un sistema su più nodi:",
      "options": [
        {
          "id": 0,
          "text": "Elaborazione più rapida delle richieste distribuite a più nodi",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Possibilità di gestire uno stato più grande della capacità di una singola macchina",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Maggiore sicurezza dei dati gestiti dal sistema di consenso",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Accesso più rapido da località differenti",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "5",
      "category": "network",
      "subcategory": "channels",
      "kind": "multiple",
      "prompt": "L'astrazione channel della libreria standard di Java permette di non occuparsi di molti dettagli riguardanti l'interazione con il mezzo di comunicazione. I vari metodi che l'astrazione richiede di implementare sono accomunati dall'uso di un parametro attachment. Il suo scopo è:",
      "options": [
        {
          "id": 0,
          "text": "Rendere accessibile in ogni momento il canale sottostante la comunicazione",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Trasportare in sicurezza il contesto della conversazione, fra metodi che saranno richiamati da thread differenti",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Distribuire fra i vari metodi i dati globali del programma",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Fornire il dato letto dal canale di comunicazione",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "6",
      "category": "concurrency",
      "subcategory": "fondamenti",
      "kind": "multiple",
      "prompt": "Quali di queste caratteristiche sono richieste per parlare di programmazione concorrente:",
      "options": [
        {
          "id": 0,
          "text": "Comunicazione tramite messaggi",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Processi separati",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Uniformità tecnologica fra i processi",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Coesistenza sullo stesso nodo di calcolo",
          "isCorrect": false
        },
        {
          "id": 4,
          "text": "Condivisione di risorse",
          "isCorrect": true
        },
        {
          "id": 5,
          "text": "Esecuzione contemporanea",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "7",
      "category": "concurrency",
      "subcategory": "sincronizzazione",
      "kind": "multiple",
      "prompt": "Le variabili Thread local:",
      "options": [
        {
          "id": 0,
          "text": "Per ciascun Thread hanno lo stesso valore, inizializzato separatamente",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Per ciascun Thread hanno lo stesso valore, inizializzato uguale per tutti e costante",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Per ciascun Thread mantengono un valore distinto, inizializzato uguale per tutti",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Per ciascun Thread mantengono un valore distinto, inizializzato separatamente",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "8",
      "category": "concurrency",
      "subcategory": "fondamenti",
      "kind": "multiple",
      "prompt": "Storicamente, la programmazione concorrente è stata introdotta per:",
      "options": [
        {
          "id": 0,
          "text": "Affrontare più problemi contemporaneamente",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Sfruttare pienamente le risorse degli elaboratori ed ottenere prestazioni più elevate",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Separare il lavoro di interazione con l'esterno dal puro calcolo",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Contrastare la legge di Moore e la differenza di velocità fra CPU e I/O",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "9",
      "category": "concurrency",
      "subcategory": "sincronizzazione",
      "kind": "multiple",
      "prompt": "Le classi del package java.concurrent.atomic",
      "options": [
        {
          "id": 0,
          "text": "Sono particolarmente efficienti in caso di modifica concorrente del dato che rappresentano perché usano nel modo migliore i lock",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Sono particolarmente efficienti in caso di modifica concorrente del dato che rappresentano perché usano (se disponibili) delle funzionalità fornite direttamente dall'hardware",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Non sono adatte nel caso di modifica concorrente perché permettono di leggere un dato che in realtà è già stato modificato",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Non sono adatte nel caso di modifica concorrente perché permettono una sola modifica alla volta",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "10",
      "category": "concurrency",
      "subcategory": "sincronizzazione",
      "kind": "multiple",
      "prompt": "Quale delle seguenti frasi è falsa per una struttura dati non Thread-Safe in caso di accesso concorrente:",
      "options": [
        {
          "id": 0,
          "text": "Può dare un risultato errato o venirsi a trovare in uno stato inconsistente",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Può lanciare un'eccezione per segnalare un accesso non consentito o pericoloso",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "È meno costosa in termini di cicli di CPU che nel caso di accesso esclusivo",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "È più performante nel caso generale",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "11",
      "category": "network",
      "subcategory": "protocolli",
      "kind": "multiple",
      "prompt": "Quali dei seguenti possono essere indicati come vantaggi dell'uso dei Datagram:",
      "options": [
        {
          "id": 0,
          "text": "La consegna di un Datagram non è legata ad una specifica porta",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Un singolo Datagram può essere inviato a molti indirizzi con una sola istruzione",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Il singolo Datagram è isolato, quindi non è necessario introdurre nel protocollo dei separatori fra messaggi diversi",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "La consegna di un singolo Datagram ha una latenza inferiore all'invio su Socket",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "12",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "Una operatore short-circuiting all'interno di una catena di elaborazione di uno Stream può:",
      "options": [
        {
          "id": 0,
          "text": "Ottenere uno Stream infinito da una funzione di trasformazione",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Produrre il risultato prima che lo Stream sia stato interamente consumato",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Cambiare l'ordine degli elementi dello Stream",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Rendere seriale l'elaborazione di uno Stream parallelo",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "13",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "L'interfaccia Collector permette di eseguire la riduzione ad un risultato di uno Stream parallelo in modo più efficiente perché:",
      "options": [
        {
          "id": 0,
          "text": "Perché non necessita di sapere la lunghezza dello Stream",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Perché gestisce un accumulatore mutabile, che riduce la pressione sulla Garbage Collection",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Perché combina i risultati intermedi più velocemente",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Perché mantiene il parallelismo dello Stream",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "14",
      "category": "oop",
      "subcategory": "parole_chiave",
      "kind": "multiple",
      "prompt": "Una classe Java dichiarata abstract è visibile:",
      "options": [
        {
          "id": 0,
          "text": "Solo dalle classe che la estendono",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Da tutte le classi dello stesso package",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "abstract non è un modificatore di visibilità",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Da qualsiasi classe",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "15",
      "category": "distributed",
      "subcategory": "fallacies",
      "kind": "multiple",
      "prompt": "La fallacia 'Latency is zero' è ancora rilevante perché:",
      "options": [
        {
          "id": 0,
          "text": "L'aumento dei nodi della rete ha compensato il miglioramento tecnologico, mantenendo il problema sostanzialmente uguale",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Le tecnologie di comunicazione hanno eliminato il problema presente in passato, ma le esigenze di concorrenza l'hanno reintrodotto in altra forma",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Dipende da una grandezza fisica",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Le tecnologie di comunicazione hanno eliminato il problema",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "16",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "In uno stream Java, una operazione short-circuiting può",
      "options": [
        {
          "id": 0,
          "text": "Causare una esecuzione seriale anche se viene richiesta l'elaborazione parallela",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Modificare gli elementi dello stream mentre li elabora",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Elaborare lo stream con un consumo di memoria costante",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Interrompere l'elaborazione prima di consumare lo stream in ingresso",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "17",
      "category": "concurrency",
      "subcategory": "sincronizzazione",
      "kind": "multiple",
      "prompt": "La parola chiave volatile fornisce un particolare tipo di garanzie di concorrenza. È necessaria a causa di:",
      "options": [
        {
          "id": 0,
          "text": "Effetti quantistici di interferenza fra celle vicine di memoria",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Peculiarità della struttura della memoria di sistemi multiprocessore",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Gestione della permanenza dei dati in seguito al riavvio della JVM",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Effetti termici delle memorie a velocità superiori ad una certa soglia",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "18",
      "category": "paradigmi",
      "subcategory": "fallacie_generali",
      "kind": "multiple",
      "prompt": "Quale delle seguenti affermazioni riguardante le Lambda Expression è vera:",
      "options": [
        {
          "id": 0,
          "text": "Rendono Java un linguaggio funzionale perché possono essere passate come parametri di una chiamata ad un metodo",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Non rendono Java un linguaggio funzionale perché non sono una entità del linguaggio, ma solo una convenienza sintattica risolta dal compilatore",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Non rendono Java un linguaggio funzionale perché non sono facilmente componibili",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Rendono Java un linguaggio funzionale perché permettono di astrarre sul comportamento di un metodo chiamato",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "19",
      "category": "network",
      "subcategory": "channels",
      "kind": "multiple",
      "prompt": "Implementare un programma di rete usando l'astrazione dei 'Channels' della libreria standard di Java permette di non occuparsi di molti dettagli riguardanti l'interazione con il mezzo di comunicazione, ma:",
      "options": [
        {
          "id": 0,
          "text": "È sufficiente sostituire il codice che gestisce la ricezione di un pacchetto di dati",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "È necessario ristrutturare il nostro codice riorganizzando in metodi che vengono richiamati all'avvenire di specifici eventi di I/O",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "È necessario riscrivere le parti che interagiscono con il mezzo di comunicazione per gestire in modo diverso la concorrenza",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "È sufficiente sostituire il codice che gestisce una nuova connessione entrante",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "20",
      "category": "paradigmi",
      "subcategory": "fallacie_generali",
      "kind": "multiple",
      "prompt": "In relazione al modo in cui il linguaggio Java viene di norma eseguito, quale di queste affermazioni è corretta:",
      "options": [
        {
          "id": 0,
          "text": "Un insieme di sorgenti in linguaggio Java deve essere ricompilato per ogni JVM specifica per ciascun sistema operativo",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Un insieme di sorgenti viene eseguito direttamente, in forma interpretata, senza necessità di compilazione",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Un sorgente per volta viene trasformato e aggiunto ad un eseguibile binario nativo",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Un insieme di sorgenti in linguaggio Java viene trasformato in bytecode, ed è quest'ultimo ad essere eseguito dalla JVM",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "21",
      "category": "network",
      "subcategory": "serializzazione",
      "kind": "multiple",
      "prompt": "Indicare quali fra le seguenti sono problematiche che rendono la serializzazione un processo complesso, che richiede molte attenzioni:",
      "options": [
        {
          "id": 0,
          "text": "Il processo di serializzazione deve essere efficiente nel tempo e nello spazio impiegati",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Un oggetto può contenere altri oggetti, che potrebbero non essere rappresentabili",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "È necessario disporre di un metodo per riordinare le parti del messaggio ricevute",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Mittente e ricevente possono avere versioni diverse dell'oggetto serializzato",
          "isCorrect": true
        },
        {
          "id": 4,
          "text": "È necessario disporre di un protocollo che delimiti correttamente le varie parti del messaggio",
          "isCorrect": false
        },
        {
          "id": 5,
          "text": "È necessario disporre di un metodo per verificare integrità e affidabilità dei dati ricevuti",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "22",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "L'oggetto Socket rappresenta una connessione attiva, e propone, come interfaccia di invio e ricezione di dati, degli stream di byte. La difficoltà nel costruire un protocollo di comunicazione risiede:",
      "options": [
        {
          "id": 0,
          "text": "nel fatto che possono essere trasmessi solo caratteri ASCII",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "nel fatto che i caratteri non stampabili possono interferire con la suddivisione delle righe",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "nel fatto che il separatore dei messaggi deve essere incluso nel contenuto",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "nel fatto che il server può ricevere più messaggi contemporaneamente, e li deve separare",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "23",
      "category": "distributed",
      "subcategory": "framework",
      "kind": "multiple",
      "prompt": "Che tipo di vantaggi si possono avere dall'adottare un framework per la costruzione di applicazioni distribuite?",
      "options": [
        {
          "id": 0,
          "text": "Aggiornamento continuo che non richiede intervento da parte dello sviluppatore",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Facilità di realizzazione perché i dettagli dei protocolli di comunicazione sono nascosti da API di livello più elevato",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Assistenza remota nella risoluzione degli errori applicativi",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Maggiore sicurezza perché i dettagli sono gestiti da persone più competenti",
          "isCorrect": true
        },
        {
          "id": 4,
          "text": "Facilità di realizzazione perché le parti più strutturali sono già implementate",
          "isCorrect": true
        },
        {
          "id": 5,
          "text": "Aggiornamento continuo che apporta benefici a tutte le parti dell'applicazione, in modo quasi automatico",
          "isCorrect": true
        },
        {
          "id": 6,
          "text": "Estrema efficienza nello sfruttare le peculiarità dell'hardware a disposizione",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "24",
      "category": "distributed",
      "subcategory": "fallacies",
      "kind": "multiple",
      "prompt": "La fallacia 'Bandwidth is infinite':",
      "options": [
        {
          "id": 0,
          "text": "E' ancora rilevante perché anche se è cresciuta la banda mediamente disponibile, è anche molto aumentata la quantità di dati trasmessi",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "È ancora rilevante in quanto dipendente da limiti fisici",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Non è più rilevante in quanto anche in mobilità la banda disponibile è ubiquitaria ed elevata",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "25",
      "category": "distributed",
      "subcategory": "fallacies",
      "kind": "multiple",
      "prompt": "La fallacia 'Network is homogeneous' è stata aggiunta alle prime sette da Gosling, proprio in seguito alle prime esperienze con Java. Oggi, la sua rilevanza:",
      "options": [
        {
          "id": 0,
          "text": "È ancora maggiore, perché le tipologie e le caratteristiche delle reti sono sempre più varie",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "È tutto sommato un problema risolto dalla diffusione dei protocolli più recenti",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Non è più rilevante dopo la diffusione delle connessioni wireless",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "È ancora rilevante, ma si tratta ormai di un problema ormai sotto controllo",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "26",
      "category": "paradigmi",
      "subcategory": "fallacie_generali",
      "kind": "multiple",
      "prompt": "I Conflict-Free Replicated Data Type consentono di riunire modifiche contemporanee da molte sorgenti. Tuttavia la loro utilità è limitata dal fatto che:",
      "options": [
        {
          "id": 0,
          "text": "sono onerosi dal punto di vista del tempo di trasmissione",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "possono rappresentare un insieme limitato di casi d'uso",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "sono onerosi dal punto di vista computazionale",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "sono complicati dalla necessità di scrivere codice ad-hoc",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "27",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "La comunicazione su Socket ha diversi vantaggi, ma il fatto che i dati vengano presentati come uno stream di byte ha i seguenti svantaggi:",
      "options": [
        {
          "id": 0,
          "text": "Deve essere definito un protocollo con cui i due lati della comunicazione riconoscono l'inizio e la fine dei messaggi",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Nel caso di comunicazione fra più di due parti sullo stesso socket, il protocollo deve permettere l'identificazione del mittente di ogni messaggio",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Le due parti devono concordare in qualche modo l'encoding delle stringhe all'interno del protocollo di comunicazione",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Le due parti della comunicazione devono inviare i propri dati il più velocemente possibile per diminuire la latenza della comunicazione",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "28",
      "category": "oop",
      "subcategory": "ereditarieta_interfacce",
      "kind": "multiple",
      "prompt": "Come molti altri linguaggi Object-Oriented, Java ha a disposizione un meccanismo di ereditarietà per estendere classi esistenti senza doverle modificare. L'ereditarietà in Java ha le seguenti caratteristiche:",
      "options": [
        {
          "id": 0,
          "text": "A causa dell'introduzione dei default methods, è possibile causare un Diamond Problem",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Una interfaccia può implementare una sola altra interfaccia",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Una classe può implementare più interfacce",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Il Diamond Problem è impossibile per costruzione",
          "isCorrect": false
        },
        {
          "id": 4,
          "text": "Una classe può ereditare da una sola altra classe",
          "isCorrect": true
        },
        {
          "id": 5,
          "text": "Una interfaccia può ereditare da un'altra interfaccia",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "29",
      "category": "oop",
      "subcategory": "parole_chiave",
      "kind": "multiple",
      "prompt": "Nel linguaggio Java, un metodo final:",
      "options": [
        {
          "id": 0,
          "text": "Il suo valore di ritorno non può essere modificato",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Deve essere reimplementato da una classe derivata",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Viene richiamato al momento della cancellazione dell'oggetto",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Non può essere reimplementato da una classe derivata",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "30",
      "category": "paradigmi",
      "subcategory": "type_system",
      "kind": "multiple",
      "prompt": "Quando si dice che il compilatore Java ha delle capacità di Type Inference si intende che:",
      "options": [
        {
          "id": 0,
          "text": "È in grado di calcolare la corretta indentazione del codice e correggerla",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "È in grado di indicare se il grafo dell'ereditarietà genera un diamond problem",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "È in grado di trasformare un tipo in un'altro senza indicazioni esterne",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "È in grado di dedurre il tipo di alcune espressioni senza che sia necessario indicarlo esplicitamente",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "31",
      "category": "concurrency",
      "subcategory": "sincronizzazione",
      "kind": "multiple",
      "prompt": "Una variabile di tipo threadLocal <T>:",
      "options": [
        {
          "id": 0,
          "text": "Possiede un valore differente per ogni Thread che vi accede",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Permette ad più Thread di accedere rapidamente al valore che contiene",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Un solo Thread per volta può accedere al valore contenuto",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Più Thread possono accedere allo stesso valore senza interferire fra loro",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "32",
      "category": "network",
      "subcategory": "protocolli",
      "kind": "multiple",
      "prompt": "La comunicazione via socket è:",
      "options": [
        {
          "id": 0,
          "text": "bidirezionale, verso un insieme di indirizzi",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "unidirezionale, verso un indirizzo o verso un insieme di indirizzi",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "bidirezionale, da punto a punto",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "unidirezionale, da punto a punto",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "33",
      "category": "network",
      "subcategory": "protocolli",
      "kind": "multiple",
      "prompt": "L'affidabilità del Datagram dipende, fra le altre cose, dalla frammentazione dei pacchetti. Ne dipende perchè:",
      "options": [
        {
          "id": 0,
          "text": "all'aumentare della frammentazione, diminuisce la probabilità che i pacchetti giungano in ordine, invalidando il messaggio",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "all'aumentare della frammentazione, diminuisce la probabilità che l'intero messaggio arrivi a destinazione",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "al diminuire della frammentazione, diminuisce la probabilità che l'intero messaggio arrivi a destinazione",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "al diminuire della frammentazione, aumenta la probabilità che i pacchetti giungano fuori ordine, invalidando il messaggio",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "34",
      "category": "concurrency",
      "subcategory": "sincronizzazione",
      "kind": "multiple",
      "prompt": "Quando si dice che la parola chiave synchronized introduce una relazione di happens-before nel codice, si intende che:",
      "options": [
        {
          "id": 0,
          "text": "Il compilatore viene istruito a garantire che il codice sorvegliato dalla parola chiave synchronized venga effettivamente eseguito dopo il codice che lo precede, indipendentemente da quanti Thread lo attraversino",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Il compilatore viene istruito a garantire che il codice sorvegliato dalla parola chiave synchronized venga eseguito contemporaneamente al codice che viene collegato dall'argomento dell'espressione",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Il compilatore viene istruito a garantire che il codice sorvegliato dalla parola chiave synchronized venga allineato al trasferimento di dati fra la memoria principale e la cache del microprocessore",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Il compilatore viene istruito a garantire che il codice sorvegliato dalla parola chiave synchronized venga effettivamente eseguito prima del codice che lo segue, e da un solo Thread alla volta",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "35",
      "category": "distributed",
      "subcategory": "fallacies",
      "kind": "multiple",
      "prompt": "La fallacia 'Transport cost is zero' è ancora valida ma con un significato diverso. Il motivo è:",
      "options": [
        {
          "id": 0,
          "text": "è cambiato il significato di trasporto: si intendeva senza condizioni, oggi è insicuro",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "il costo del trasporto oggi tende progressivamente a zero",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "oggi il trasporto è su tecnologie differenti, quindi la metrica del costo ora include la latenza",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "è cambiato il significato di costo: si intendeva costo monetario, ora si intende costo energetico",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "36",
      "category": "paradigmi",
      "subcategory": "actor_model",
      "kind": "multiple",
      "prompt": "Quale delle seguenti affermazioni è corretta riguardo allo stato di un Attore:",
      "options": [
        {
          "id": 0,
          "text": "Lo stato di un Attore viene modificato da ogni messaggio ricevuto",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Lo stato di un Attore può essere modificato solo dall'Attore stesso o dall'Attore che lo ha creato",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Lo stato di un Attore può essere modificato da più messaggi contemporaneamente, e va gestito con variabili thread-safe",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Lo stato di un Attore è privato, e può essere solo modificato alla ricezione di un messaggio",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "37",
      "category": "distributed",
      "subcategory": "framework",
      "kind": "multiple",
      "prompt": "Che tipo di rischi devono essere considerati nella scelta e nell'adozione di un framework per la costruzione di applicazioni distribuite?",
      "options": [
        {
          "id": 0,
          "text": "Errori operativi dovuti a bachi nel codice del framework",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Indisponibilità di assistenza remota nella risoluzione degli errori applicativi",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Direzione di sviluppo non allineata con le esigenze dell'evoluzione dell'applicazione",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Errori operativi dovuti a configurazioni di default insicure o difficili da capire",
          "isCorrect": true
        },
        {
          "id": 4,
          "text": "Casi d'uso particolari non coperti dalle funzionalità del framework",
          "isCorrect": true
        },
        {
          "id": 5,
          "text": "Difficoltà a rimuovere gli errori dal proprio codice una volta introdotto il framework",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "38",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "Quale dei seguenti non è uno Stream Flag, cioè una caratteristica che uno Stream può dichiarare ed uno operatore (intermedio o terminale) utilizzare per organizzare l'esecuzione:",
      "options": [
        {
          "id": 0,
          "text": "SUBSIZED - lo stream può essere diviso in partizioni di dimensione nota",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "UNTYPED - non è noto a priori il tipo degli elementi",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "CONCURRENT - lo stream supporta l'elaborazione parallela",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "NONNULL - tutti gli elementi sono diversi da null",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "39",
      "category": "concurrency",
      "subcategory": "thread_stati",
      "kind": "multiple",
      "prompt": "Un Thread può trovarsi in diversi stati di attesa: waiting, timed waiting, blockers. In cosa si distinguono?",
      "options": [
        {
          "id": 0,
          "text": "Dipendono da questioni tecnologiche mediate dalla JVM",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Dipendono dalla chiamata di libreria std usata per richiedere una risorsa",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Sono gestiti da strutture sintattiche differenti",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "È diverso il motivo dell'attesa, la sua durata ed il modo in cui si esce dallo stato",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "40",
      "category": "network",
      "subcategory": "protocolli",
      "kind": "multiple",
      "prompt": "È importante gestire velocemente l'accettazione di una nuova connessione su di un ServerSocket perché:",
      "options": [
        {
          "id": 0,
          "text": "Finché non c'è un thread che attende in ServerSocket::accept(), le operazioni di scrittura sui Socket non riprendono",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Finché non c'è un thread che attende in ServerSocket::accept(), le nuove richieste di connessione si accodano su di un buffer del sistema operativo che può avere una lunghezza molto limitata",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Finché non c'è un thread che attende in ServerSocket::accept(), le operazioni di lettura sui Socket non riprendono",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Finché not c'è un thread che attende in ServerSocket::accept(), i buffer di invio e ricezione dati del sistema operativo non sono sorvegliati e potrebbero riempirsi",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "41",
      "category": "paradigmi",
      "subcategory": "fallacie_generali",
      "kind": "multiple",
      "prompt": "Quali di queste sono problematiche dell'esecuzione concorrente di programmi:",
      "options": [
        {
          "id": 0,
          "text": "clock skew",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "race conditions",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "instruction ordering",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "deadlock",
          "isCorrect": true
        },
        {
          "id": 4,
          "text": "Amdahl's law",
          "isCorrect": false
        },
        {
          "id": 5,
          "text": "indeterminismo",
          "isCorrect": true
        },
        {
          "id": 6,
          "text": "preemption",
          "isCorrect": false
        },
        {
          "id": 7,
          "text": "starvation",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "42",
      "category": "paradigmi",
      "subcategory": "actor_model",
      "kind": "multiple",
      "prompt": "In reazione alla ricezione di un messaggio, un attore può:",
      "options": [
        {
          "id": 0,
          "text": "Creare nuovi attori",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Modificare il suo stato interno",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Inviare messaggi ad attori di cui ha un riferimento",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Modificare lo stato di un attore di cui ha un riferimento",
          "isCorrect": false
        },
        {
          "id": 4,
          "text": "Inviare un messaggio ad un attore di un altro nodo del sistema",
          "isCorrect": false
        },
        {
          "id": 5,
          "text": "Eliminare un attore di cui ha un riferimento",
          "isCorrect": false
        },
        {
          "id": 6,
          "text": "Modificare il suo comportamento per la ricezione dei prossimi messaggi",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "43",
      "category": "concurrency",
      "subcategory": "future_promise",
      "kind": "multiple",
      "prompt": "Un oggetto Future rappresenta:",
      "options": [
        {
          "id": 0,
          "text": "Un calcolo che potrebbe produrre un risultato dopo un certo tempo",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Una generica esecuzione concorrente",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Il risultato di un calcolo parallelo terminato correttamente",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Un calcolo concorrente terminato in modo errato",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "44",
      "category": "oop",
      "subcategory": "controllo_flusso",
      "kind": "multiple",
      "prompt": "Quale di queste caratteristiche è propria della sintassi switch-case come espressione:",
      "options": [
        {
          "id": 0,
          "text": "I risultati devono essere tutti valori della stessa interfaccia",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Ogni caso deve produrre un risultato diverso",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "È possibile il fall-through da un caso all'altro",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "L'elenco delle opzioni deve essere esaustivo",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "45",
      "category": "paradigmi",
      "subcategory": "fallacie_generali",
      "kind": "multiple",
      "prompt": "Lo scopo delle Reactive Extensions è:",
      "options": [
        {
          "id": 0,
          "text": "Fornire un insieme di componenti per l'elaborazione distribuita di stream di valori",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Fornire una semantica per definire elaborazioni asincrone di sequenze di oggetti",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Fornire un modello di esecuzione di elaborazioni parallele di oggetti",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Fornire una API per definire elaborazioni di sequenze di oggetti",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "46",
      "category": "oop",
      "subcategory": "parole_chiave",
      "kind": "multiple",
      "prompt": "Nel linguaggio Java, una variabile final:",
      "options": [
        {
          "id": 0,
          "text": "Può contenere un valore di un solo tipo",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Richiama un metodo al momento della cancellazione",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Richiama un metodo quando viene modificata",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Deve essere inizializzata contestualmente alla definizione, ed il suo valore non può essere cambiato",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "47",
      "category": "paradigmi",
      "subcategory": "fallacie_generali",
      "kind": "multiple",
      "prompt": "I valori in un programma Java possono essere:",
      "options": [
        {
          "id": 0,
          "text": "Oggetti, cioè istanze di una classe, oppure valori primitivi, oppure il valore null",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Solo oggetti, cioè istanze di una classe",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Solo classi",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Solo valori primitivi e null",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "48",
      "category": "oop",
      "subcategory": "ereditarieta_interfacce",
      "kind": "multiple",
      "prompt": "Perché nel linguaggio Java si è deciso di introdurre i metodi di default nelle Interfacce?",
      "options": [
        {
          "id": 0,
          "text": "Per inseguire una feature richiesta dal mercato",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Per rendere più difficile modificare l'implementazione delle interface in modi non previsti",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Per evitare una possibilità di realizzare un diamond problem",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Per poter estendere delle interfacce consolidate senza richiedere l'aggiornamento del codice esistente",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "49",
      "category": "oop",
      "subcategory": "visibilita_classi",
      "kind": "multiple",
      "prompt": "Una classe Java dichiarata senza modificatori di visibilità:",
      "options": [
        {
          "id": 0,
          "text": "È visibile da ogni classe del sistema",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Un modificatore di visibilità è obbligatorio",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Da ogni classe dello stesso package",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Solo dalle classe che la estendono",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "50",
      "category": "concurrency",
      "subcategory": "thread_stati",
      "kind": "multiple",
      "prompt": "Un Thread esce dallo stato timed waiting quando:",
      "options": [
        {
          "id": 0,
          "text": "Trascorre esattamente il tempo impostato (e solo in questo caso)",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Ottiene il lock che stava aspettando o viene interrotto",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Ottiene il lock che stava aspettando, oppure viene interrotto o trascorre il timeout impostato",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Viene interrotto (e solo in questo caso)",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "51",
      "category": "paradigmi",
      "subcategory": "fallacie_generali",
      "kind": "matching",
      "prompt": "Ordina le strutture indicate secondo la sequenza con cui vengono eseguite:",
      "left": [
        "Inizializzatore",
        "Costruttore Bar",
        "Inizializzatore statico",
        "Costruttore Foo"
      ],
      "right": [
        "1",
        "2",
        "3",
        "4"
      ],
      "correctMatches": {
        "0": 2,
        "1": 3,
        "2": 0,
        "3": 1
      },
      "code": "class Foo {\n    Foo (int a) {\n        //Costruttore Foo\n    }\n}\nclass Bar extends Foo {\n    static {\n        //Inizializzatore statico\n    }\n    {\n        //Inizializzatore\n    }\n    Bar (int a, string b) {\n        super(a);\n        //Costruttore Bar\n    }\n}"
    },
    {
      "id": "52",
      "category": "network",
      "subcategory": "protocolli",
      "kind": "multiple",
      "prompt": "In questo codice d'esempio, in che punto va inserita la chiusura della risorsa DatagramSocket:",
      "options": [
        {
          "id": 0,
          "text": "In un blocco finally da aggiungere in coda al blocco try",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Nel punto A",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Nel punto B",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Non è necessaria",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "53",
      "category": "reactive",
      "subcategory": "observable",
      "kind": "multiple",
      "prompt": "Nelle Reactive Extensions, quali di queste operazioni non è necessario (o possibile) specificare per elaborare gli oggetti emessi da un Observable:",
      "options": [
        {
          "id": 0,
          "text": "Il comportamento alla ricezione di un oggetto",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Il comportamento al termine dello stream di oggetti",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Il numero di oggetti che l'Observable è autorizzato ad inviare",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Il comportamento alla richiesta di separazione di uno stream parallelo",
          "isCorrect": true
        },
        {
          "id": 4,
          "text": "Il comportamento alla ricezione di un errore",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "54",
      "category": "concurrency",
      "subcategory": "sincronizzazione",
      "kind": "matching",
      "prompt": "Associare ciascuna struttura di gestione della concorrenza al suo ambito di applicazione:",
      "left": [
        "Object.wait()",
        "synchronized",
        "Condition",
        "Lock",
        "Semaphore"
      ],
      "right": [
        "Gestione di un insieme omogeneo di risorse",
        "Gestione esplicita, senza legami sintattici, del blocco e dello sblocco della sezione critica",
        "Gestione della concorrenza tramite la struttura sintattica del codice",
        "Gestione dell'accesso alla stessa sezione critica in condizioni di blocco e/o sblocco differenti",
        "Gestione esplicita dell'accesso ad un singolo oggetto"
      ],
      "correctMatches": {
        "0": 4,
        "1": 2,
        "2": 3,
        "3": 1,
        "4": 0
      }
    },
    {
      "id": "55",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "Nella implementazione degli Stream della libreria standard, che vantaggio si ottiene dal fatto che la API consente di costruire la catena di elaborazione separatamente dalla sua esecuzione?",
      "options": [
        {
          "id": 0,
          "text": "L'implementazione può analizzare le operazione della catena, e decidere se eseguirle parallelamente o in serie",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "L'implementazione può sempre sapere se dovrà eseguire un numero finito o meno di elaborazioni in funzione unicamente delle operazioni intermedie",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "L'implementazione può analizzare le operazioni della catena, e prendere decisioni su come applicarle in funzione delle loro caratteristiche",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "56",
      "category": "concurrency",
      "subcategory": "deadlock",
      "kind": "matching",
      "prompt": "Associare ad ogni condizione di Coffmann una strategia utile per rimuoverla:",
      "left": [
        "Attesa Circolare",
        "Mutua Esclusione",
        "Risorse non riassegnabili",
        "Possesso e attesa"
      ],
      "right": [
        "Pre-emption",
        "Algoritmi lock-free",
        "Assegnazione delle risorse transazionale",
        "Esecuzione fuori ordine",
        "Ordinamento dell'acquisizione"
      ],
      "correctMatches": {
        "0": 4,
        "1": 1,
        "2": 0,
        "3": 2
      }
    },
    {
      "id": "57",
      "category": "distributed",
      "subcategory": "distribuzione_stato",
      "kind": "multiple",
      "prompt": "Quali vantaggi si vogliono ottenere nel distribuire lo stato di un sistema su più nodi:",
      "options": [
        {
          "id": 0,
          "text": "Suddivisione del lavoro fra più nodi per una elaborazione più rapida delle richieste",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Affidabilità rispetto al guasto fisico di uno o più nodi",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Maggiore sicurezza dei dati gestiti dal sistema di consenso",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Gestione di una mole di dati più grande della capacità di una singola macchina",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "58",
      "category": "network",
      "subcategory": "protocolli",
      "kind": "multiple",
      "prompt": "Quali dei seguenti possono essere indicati come vantaggi dell'uso dell'oggetto Socket per la comunicazione:",
      "options": [
        {
          "id": 0,
          "text": "La connessione con un Socket non è legata ad una specifica porta del nodo connesso",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "La comunicazione può essere bidirezionale",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "L'orientamento alla connessione del Socket permette di trasferire in modo affidabile quantità di dati rilevanti",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "I buffer a disposizione per le connessioni su Socket sono più ampi di quelli per i Datagram",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "59",
      "category": "reactive",
      "subcategory": "subject",
      "kind": "multiple",
      "prompt": "Nell'astrazione delle Reactive Extensions, un subject può:",
      "options": [
        {
          "id": 0,
          "text": "Osservare uno Stream esaminando solo alcuni elementi",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Osservare altri subject e observable alterando la struttura dello stream fra di loro",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Osservare diversi observable, e comportarsi da observable esso stesso, modificando la struttura dell'elaborazione dello stream",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Osservare uno Stream in modalità parallela",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "60",
      "category": "concurrency",
      "subcategory": "thread_stati",
      "kind": "multiple",
      "prompt": "Il modello dei Thread permette ad un Processo di organizzare più linee di esecuzione al suo interno incorrendo in una minore penalità di cambiamento del contesto durante l'esecuzione. Tuttavia, si ritrova a dover gestire:",
      "options": [
        {
          "id": 0,
          "text": "L'accesso e la condivisione delle risorse",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "La ricezione degli eventi di rete",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "L'invio dei byte alle periferiche di I/O",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "L'organizzazione della memoria esterna",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "61",
      "category": "concurrency",
      "subcategory": "sincronizzazione",
      "kind": "multiple",
      "prompt": "Il compilatore Java può riordinare le istruzioni di un blocco di codice in seguito a considerazioni di ottimizzazione ed efficienza. Per imporre un ordinamento preciso è possibile:",
      "options": [
        {
          "id": 0,
          "text": "Usare la parola chiave synchronized per introdurre un ordinamento specifico, con una relazione di happens-before",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Usare la parola chiave final per prevenire modifiche di questo tipo durante la compilazione",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Usare la parola chiave volatile per segnalare un blocco di codice che non va riordinato",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Usare la parola chiave strictfp per richiedere una semantica precisa delle istruzioni riordinate",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "62",
      "category": "paradigmi",
      "subcategory": "actor_model",
      "kind": "multiple",
      "prompt": "Quale di queste azioni un attore non può compiere durante l'elaborazione di un messaggio:",
      "options": [
        {
          "id": 0,
          "text": "creare un altro attore",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "interrompere l'elaborazione di un altro attore",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "modificare il proprio stato",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "inviare un numero finito di messaggi",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "63",
      "category": "oop",
      "subcategory": "visibilita_classi",
      "kind": "multiple",
      "prompt": "I membri di una interfaccia Java:",
      "options": [
        {
          "id": 0,
          "text": "Nessuno di essi deve specificare una implementazione",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Sono immutabili",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Sono tutti pubblici, senza necessità di indicarlo",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Sono indipendenti dal tipo di appartenenza",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "64",
      "category": "network",
      "subcategory": "protocolli",
      "kind": "multiple",
      "prompt": "È importante gestire velocemente l'accettazione di un pacchetto da una DatagramSocket perché:",
      "options": [
        {
          "id": 0,
          "text": "Se non c'è un thread in attesa della ricezione di un pacchetto, questo viene scartato",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Se non c'è un thread in attesa su DatagramSocket:receive(), nessun pacchetto viene ricevuto",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Se c'è un thread in attesa su DatagramSocket:receive(), gli invii sono bloccati",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "I pacchetti ricevuti vengono conservati in buffer limitati; se si riempiono, i messaggi successivi sono scartati",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "65",
      "category": "reactive",
      "subcategory": "reactive_streams",
      "kind": "multiple",
      "prompt": "I Reactive Stream aggiungono, al modello semantico delle Reactive Extensions, i seguenti concetti:",
      "options": [
        {
          "id": 0,
          "text": "i componenti della pipeline possono dichiarare quanti elementi possono emettere ai componenti successivi",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "i componenti della pipeline possono lanciare eccezioni",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "i componenti della pipeline possono avere uno stato distribuito",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "i componenti della pipeline possono esercitare una back-pressure nei confronti dei componenti che li precedono",
          "isCorrect": true
        },
        {
          "id": 4,
          "text": "i componenti della pipeline possono essere distribuiti",
          "isCorrect": true
        },
        {
          "id": 5,
          "text": "i componenti della pipeline possono chiudere in anticipo l'elaborazione dello stream",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "66",
      "category": "concurrency",
      "subcategory": "thread_stati",
      "kind": "multiple",
      "prompt": "Quale delle seguenti affermazioni riguardo ai rapporti fra Processi, Thread e Fiber è vera:",
      "options": [
        {
          "id": 0,
          "text": "Le risorse dei Processi sono controllate dal Sistema Operativo, mentre all'interno dei Processi i Thread devono direttamente controllare il loro accesso. Le Fiber rendono esplicita la concorrenza con lo scopo di essere ancora più leggere dei Thread.",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "I Processi sono raggruppamenti logici di risorse che nei Thread vengono associati a risorse fisiche. Le Fiber sono un miglioramento dei Thread.",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Una volta allocata una risorsa, non può essere sottratta ad un Processo. Ad un Thread invece può essere sottratta, mettendolo in stato waiting. Le Fiber rendono la gestione della concorrenza più esplicita.",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "I Processi evitano il deadlock attraverso l'ordinamento delle priorità. I Thread invece non sono ordinati e devono essere manualmente controllati per evitare conflitti nella gestione delle risorse. Le Fiber sono una evoluzione più efficiente dei Thread.",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "67",
      "category": "distributed",
      "subcategory": "consenso",
      "kind": "multiple",
      "prompt": "Se in un sistema distribuito i nodi non trovano un consenso sullo stato del sistema, può accadere che:",
      "options": [
        {
          "id": 0,
          "text": "Le risposte del sistema siano molteplici e conflittuali perché raccolgono i dati da più nodi.",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Le risposte del sistema siano inefficienti perché le differenti versioni dello stato si accavallano in una race condition.",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Le risposte del sistema siano incoerenti e dipendano da quale nodo viene contattato.",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Le risposte del sistema non siano disponibili in quanto gli stati differenti si annullano.",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "68",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "Uno stream rappresenta una sequenza di elementi, potenzialmente infinita. L'obiettivo di questa astrazione è:",
      "options": [
        {
          "id": 0,
          "text": "Permettere di descrivere l'elaborazione in termini di trasformazioni, e non dell'iterazione",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Fornire l'API per attraversare più rapidamente la collezione",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Uniformare l'accesso a più collezioni di struttura differente",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Permettere di controllare più finemente l'avanzamento dell'iterazione",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "69",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "Perché l'elaborazione dia un risultato corretto, è richiesto che le operazioni interne siano:",
      "options": [
        {
          "id": 0,
          "text": "Prive di uno stato interno",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Implementate da oggetti diversi",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Prive di allocazioni di nuovi oggetti",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Non invasive: non devono modificare o interferire con gli elementi dello Stream",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "70",
      "category": "concurrency",
      "subcategory": "thread_stati",
      "kind": "multiple",
      "prompt": "Un Thread esce dallo stato running:",
      "options": [
        {
          "id": 0,
          "text": "Termina l'esecuzione, passando allo stato terminated",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Gli viene sottratta la CPU, e passa allo stato runnable",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Si pone in attesa di una risorsa, e passa allo stato waiting",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Gli viene assegnata la CPU e passa allo stato runnable",
          "isCorrect": false
        },
        {
          "id": 4,
          "text": "Si pone in attesa di una risorsa per un tempo limitato, passando allo stato timed waiting",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "71",
      "category": "paradigmi",
      "subcategory": "fallacie_generali",
      "kind": "multiple",
      "prompt": "Quando di un sistema reattivo si indicano le sue qualità come Responsive, Resilient, Elastic, Message-Oriented, con la qualità 'Message-Oriented' si intende:",
      "options": [
        {
          "id": 0,
          "text": "Il sistema risponde proporzionalmente alla quantitá di richieste in ingresso",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "L'unica primitiva di comunicazione fra i componenti è il messaggio asincrono.",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Il sistema è disponibile anche in caso di guasto parziale.",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Il sistema fornisce delle funzionalità di coda di messaggi distribuita.",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "72",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "In questo codice di esempio, una eccezione lanciata dall'oggetto out ha come effetto:",
      "options": [
        {
          "id": 0,
          "text": "La chiusura della sola risorsa in",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "La chiusura delle risorse serverSocker e socker, ma non di in",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "La chiusura di tutte le risorse e l'uscita dal blocco",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "L'uscita dal blocco con perdita delle risorse allocate",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "73",
      "category": "distributed",
      "subcategory": "consenso",
      "kind": "multiple",
      "prompt": "Il teorema CAP afferma che un sistema distribuito, in caso di partizione dei suoi nodi in gruppi che non comunicano fra loro, deve scegliere il suo comportamento fra:",
      "options": [
        {
          "id": 0,
          "text": "Consistenza e latenza",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Correttezza ed efficienza",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Consistenza e disponibilità",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Certezza delle risposte e latenza della stessa",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "74",
      "category": "oop",
      "subcategory": "generics_wildcards",
      "kind": "multiple",
      "prompt": "Quali di questi elementi fanno parte della firma di un metodo:",
      "options": [
        {
          "id": 0,
          "text": "Nome del metodo.",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Visibilità del metodo.",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Tipo del valore di ritorno.",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Parametri di tipo.",
          "isCorrect": true
        },
        {
          "id": 4,
          "text": "Elenco dei tipi degli argomenti.",
          "isCorrect": true
        },
        {
          "id": 5,
          "text": "Elenco dei nomi degli argomenti.",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "75",
      "category": "reactive",
      "subcategory": "reactive_streams",
      "kind": "multiple",
      "prompt": "In un sistema che implementa la specifica Reactive Streams, si intende con Back-Pressure:",
      "options": [
        {
          "id": 0,
          "text": "La latenza introdotta dal nodo più lento dello stream",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "La possibilità per un nodo di indicare al precedente quanti oggetti è in grado di elaborare",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "La quantità di dati gestibile dalle interferenze di rete fra i nodi",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "La possibilità per un nodo di indicare al successivo quanti oggetti è in grado di inviargli",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "76",
      "category": "concurrency",
      "subcategory": "thread_stati",
      "kind": "multiple",
      "prompt": "I Virtual Thread vengono introdotti per:",
      "options": [
        {
          "id": 0,
          "text": "Aumentare l'efficienza del codice che usa operazioni bloccanti senza doverlo modificare",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Rendere più efficiente il codice reattivo",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Aumentare il livello di prestazioni che si può ottenere senza dover riscrivere il codice in un altro paradigma, per esempio reattivo",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Aumentare le prestazioni dei carichi a basso Blocking Factor",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "77",
      "category": "paradigmi",
      "subcategory": "jvm_bytecode",
      "kind": "multiple",
      "prompt": "Con i metodi di esecuzione nativa, il codice Java viene compilato direttamente in un eseguibile, senza la necessità di usare la JVM. Questo comporta:",
      "options": [
        {
          "id": 0,
          "text": "Prestazioni a regime che possono essere superiori a quelle dell'esecuzione normale (JIT)",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Una diminuzione delle risorse necessarie durante l'esecuzione",
          "isCorrect": true
        },
        {
          "id": 2,
          "text": "Un tempo di compilazione più lungo",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Un aumento delle risorse necessarie durante l'esecuzione",
          "isCorrect": false
        },
        {
          "id": 4,
          "text": "Un avvio più rapido dell'applicazione",
          "isCorrect": true
        },
        {
          "id": 5,
          "text": "Prestazioni a regime che possono essere inferiori a quelle dell'esecuzione normale(JIT)",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "78",
      "category": "network",
      "subcategory": "protocolli",
      "kind": "multiple",
      "prompt": "La comunicazione su Datagram presenta alcuni vantaggi rispetto ai Socket, per esempio la possibilità di inviare messaggi broadcast. Tuttavia è afflitta anche dai seguenti svantaggi:",
      "options": [
        {
          "id": 0,
          "text": "Le due parti devono concordare in qualche modo l'encoding delle stringhe",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Deve essere definito un protocollo con cui i due lati della comunicazione riconoscono inizio e fine dei messaggi",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "La probabilità di successo della comunicazione diminuisce con il crescere della lunghezza del messaggio",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Le due parti della comunicazione devono inviare i propri dati il più velocemente possibile per diminuire la latenza della comunicazione",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "79",
      "category": "paradigmi",
      "subcategory": "actor_model",
      "kind": "multiple",
      "prompt": "Quali delle seguenti affermazioni sono corrette riguardo al comportamento di un Attore",
      "options": [
        {
          "id": 0,
          "text": "Il comportamento di un attore può cambiare dopo la ricezione di un messaggio",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Il comportamento di un attore deve essere thread-safe",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Il comportamento di un attore non può agire sul suo stato interno",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Il comportamento di un attore definisce come reagisce ad un messaggio",
          "isCorrect": true
        },
        {
          "id": 4,
          "text": "Il comportamento di un attore non può cambiare dopo la sua creazione",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "80",
      "category": "reactive",
      "subcategory": "java_streams",
      "kind": "multiple",
      "prompt": "Gli Stream permettono di rendere parallela l'esecuzione della pipeline delle operazioni definite su di essi, tuttavia non permettono di indicare esplicitamente il grado di parallelismo da usare, operando una scelta ben definita. In quali casi può essere necessario modificare il comportamento di default:",
      "options": [
        {
          "id": 0,
          "text": "Un algoritmo che genera molta I/O può beneficiare dall'essere parallelizzato su di un numero maggiore di Threads rispetto al default",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Un algoritmo che occupa costantemente la CPU può beneficiare dall'essere parallelizzato su di un numero maggiore di Threads rispetto al default",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Un algoritmo che occupa costantemente la CPU può beneficiare dall'essere parallelizzato su di un numero inferiore di Threads rispetto al default",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Un algoritmo che comporta molti cambi di contesto può beneficiare dall'essere parallelizzato su di un numero inferiore di Threads rispetto al default",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "81",
      "category": "paradigmi",
      "subcategory": "fallacie_generali",
      "kind": "multiple",
      "prompt": "Quando di un sistema reattivo si indicano le sue qualità come Responsive, Resilient, Elastic, Message-Oriented, con 'Elastic' si intende:",
      "options": [
        {
          "id": 0,
          "text": "Il sistema è in grado di consumare più o meno risorse per ottenere maggiori prestazioni o seguire un calo delle richieste",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Il sistema risponde proporzionalmente alla quantità di richiesta in ingresso",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Il sistema consuma dati da diverse fonti di ingresso",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Il sistema è disponibile anche in caso di guasto parziale",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "82",
      "category": "oop",
      "subcategory": "controllo_flusso",
      "kind": "multiple",
      "prompt": "Quale delle seguenti affermazioni riguardo l'espressione return è corretta:",
      "options": [
        {
          "id": 0,
          "text": "In un metodo void è necessario inserire almeno una istruzione return vuota",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "In un metodo void, se viene indicato un valore questo viene ignorato",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "In un metodo non void, ogni percorso di codice deve terminare con una istruzione return",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "In un metodo non void è opzionale, in quanto viene ritornato il risultato dell'ultima espressione del metodo",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "83",
      "category": "oop",
      "subcategory": "parole_chiave",
      "kind": "multiple",
      "prompt": "Con la parola chiave sealed si può indicare una classe che:",
      "options": [
        {
          "id": 0,
          "text": "Non può essere estesa",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "E' digitalmente firmata per sicurezza",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Elenca esplicitamente le classi che possono ereditare da essa",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Può essere istanziata solo in oggetti immutabili",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "84",
      "category": "reactive",
      "subcategory": "observable",
      "kind": "multiple",
      "prompt": "Un Observable nel modello delle Reactive Extension si distingue radicalmente da uno Stream della libreria std di Java, perchè:",
      "options": [
        {
          "id": 0,
          "text": "Emette elementi nel tempo. Lo scorrere del tempo è un concetto esplicitamente gestito dal modello Rx",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Può trovarsi su più nodi di calcolo e distribuire il carico fra essi",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "E' più efficiente nel costruire ed eseguire la pipeline di elaborazione",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Non emette errori. Ogni possibile casistica d'errore è gestita a priori",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "85",
      "category": "paradigmi",
      "subcategory": "fallacie_generali",
      "kind": "multiple",
      "prompt": "Le Conflict-Free Replicated Data-Types sono strutture dati particolarmente utili in alcuni tipi di applicazioni distribuite. La loro caratteristica è di fornire la garanzia che:",
      "options": [
        {
          "id": 0,
          "text": "Modifiche fatte su nodi differenti non appaiono mai contemporaneamente",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Modifiche fatte su nodi differenti possono essere riordinate in sequenza casuale",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Modifiche fatte contemporaneamente su nodi differenti sono sempre riconciliabili",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Modifiche fatte contemporaneamente su nodi differenti possono essere individuate e segnalate come conflitto",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "86",
      "category": "paradigmi",
      "subcategory": "type_system",
      "kind": "multiple",
      "prompt": "La classe java.util.Optional è utile per",
      "options": [
        {
          "id": 0,
          "text": "Ottenere dei pattern di programmazione differenziata",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Modellare collezioni potenzialmente vuote",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Rendere esplicito il significato del valore di ritorno nullo",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Nessuna delle precedenti",
          "isCorrect": false
        }
      ]
    },
    {
      "id": "87",
      "category": "distributed",
      "subcategory": "consenso",
      "kind": "multiple",
      "prompt": "Il problema del consenso fra nodi di sistemi distribuiti deriva:",
      "options": [
        {
          "id": 0,
          "text": "Dalla necessità di organizzare l'elezione del nodo leader",
          "isCorrect": false
        },
        {
          "id": 1,
          "text": "Dalla necessità di individuare i nodi non funzionanti",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Da problemi di gestione della latenza di comunicazione dei nodi stessi",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Dalla necessità di garantire che tutti i nodi abbiano la stessa versione di un dato",
          "isCorrect": true
        }
      ]
    },
    {
      "id": "88",
      "category": "concurrency",
      "subcategory": "thread_stati",
      "kind": "multiple",
      "prompt": "I Virtual Thread permettono di avere dei vantaggi durante l'esecuzione concorrente, senza sintassi specifica presentano le seguenti caratteristiche:",
      "options": [
        {
          "id": 0,
          "text": "Ottenibile per uso singolo, no pool",
          "isCorrect": true
        },
        {
          "id": 1,
          "text": "Richiedono il supporto da parte dello strato di virtualizzazione hardware",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Ogni API bloccante si occupa di gestirne il corretto montaggio e smontaggio",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Disponibili in numero limitato per ogni JVM",
          "isCorrect": false
        }
      ]
    }
  ]
}